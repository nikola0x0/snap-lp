Saros
Search…
⌘
K

English
SAROS
SAROS DLMM
SAROS AMM
INTEGRATION
SAROS DLMM
Onboarding and Guides
Saros DLMM: Introduction
Liquidity Lifecycle: Deployment, Management & Rebalancing
Permissionless Saros DLMM Pools
Understanding Your Risks as a Liquidity Provider on Saros DLMM
Shapes and Strategies
Liquidity Shapes
Getting Started with Basic Liquidity Strategies
Advanced Liquidity Strategies on Saros
Managing Out-of-Range Liquidity on Saros
Single-Sided Liquidity Strategies on Saros
Rewards
Concentrated Incentives (CI) on Saros
Technical Design
Technical Guides
User Guides
How to Create a Pool on Saros DLMM
How to Add and Remove Liquidity on Saros DLMM
How to Swap on Saros DLMM
FAQs
SAROS AMM
SarosSwap
SarosFarm
SarosStake
SarosSnapShot
FAQs
Go to DEX
SAROS GARDEN
Introduction
How to stake on Saros Garden
How to unstake from Saros Garden
How to redeem BERRY
SAROS SWAP
How to Swap on Saros Swap
ALL ABOUT $SAROS
Saros Token ($SAROS)
INTEGRATION
Saros AMM
Saros DLMM
LEGAL
TERMS OF SERVICE
Privacy Policy
AUDITS
SarosSwap
SarosFarm & SarosStake
Saros DLMM
Saros Garden
Saros Token (\$SAROS)
OFFICIAL LINKS
Saros Community
Brand Assets
Powered by GitBook
What's Saros DLMM?
Saros DLMM Key Features
Concentrated Liquidity
Surge Pricing
Bin Architecture
Zero Slippage Swaps
Copy

SAROS DLMM
Onboarding and Guides
Saros DLMM: Introduction
What's Saros DLMM?
Welcome to Saros DLMM (Dynamic Liquidity Market Maker) - the engine that powers the Internet Financial Market on Solana. Think of it as the facilitator for all of your trades behind the scenes.

Instead of using complicated order books like traditional CEXs or slippage-bearing models of AMMs, Saros DLMM runs on Liquidity Book technology - with pools of tokens provided by users (like you!). These pools make it fast and seamless for anyone to trade directly on Solana - no middlemen, just pure DeFi power.

Saros DLMM isn’t just about speed. It’s also built to make trading more efficient and rewarding for liquidity providers — the people who help power the system by adding their tokens to these pools. It’s like earning fuel points every time someone uses the gas you pumped.

Whether you're new to DeFi or already a seasoned pro, Saros DLMM offers a smoother, smarter way to trade and earn.

Ready to dive deeper? Check out our full guide to learn more!

Saros DLMM Key Features
Saros DLMM isn't just a trading platform—it's a feature-rich hub crafted to enhance the experience for both traders and liquidity providers. Let's delve into some of its standout features:

Concentrated Liquidity: Enhance Your Capital Utilization

Surge Pricing: Liquidity Providers earn more

Bin Architecture: Flexible Liquidity Management

Zero-slippage Swaps: Get the best trading rates for traders.

Concentrated Liquidity
Unlike traditional AMMs that distribute liquidity across broad price ranges, Saros DLMM enables providers to concentrate capital within targeted price bands. This boosts capital efficiency, allowing for larger trades with reduced slippage. As a result, traders benefit from more stable pricing, while liquidity providers can earn higher fees.

Surge Pricing
Saros DLMM features a dynamic surge pricing model that adjusts swap fees in real-time based on market volatility. During periods of high price fluctuation, trading fees increase slightly and disincentivize excessive trading while liquidity providers are compensated with higher returns, helping to mitigate risks such as impermanent loss and incentivizing deeper liquidity provisioning when it’s most needed.

Bin Architecture
Saros DLMM introduces a unique bin-based system, where liquidity is divided into discrete pools at fixed price levels. Each bin represents liquidity at a specific price point, and together, they form a full liquidity pool. This structure minimizes price impact during trades, leading to better execution for traders. For liquidity providers, it enables precise, strategy-driven fund allocation and maximizing returns by aligning with market movements.

Zero Slippage Swaps
In traditional AMMs, asset prices shift based on pool composition — each trade alters the ratio, causing price movement. As a result, buyers push prices up and sellers push them down, leading to slippage — where the final trade price differs from the quoted one.

With Saros DLMM’s bin architecture, swaps are executed at fixed price levels, enabling zero slippage. This means the price you see is the price you get, allowing for more accurate, efficient, and predictable trading.

Previous
Onboarding and Guides
Next
Liquidity Lifecycle: Deployment, Management & Rebalancing
Last updated 5 months ago

Saros DLMM: Introduction | Saros

Saros
Search…
⌘
K

English
SAROS
SAROS DLMM
SAROS AMM
INTEGRATION
SAROS DLMM
Onboarding and Guides
Saros DLMM: Introduction
Liquidity Lifecycle: Deployment, Management & Rebalancing
Permissionless Saros DLMM Pools
Understanding Your Risks as a Liquidity Provider on Saros DLMM
Shapes and Strategies
Liquidity Shapes
Getting Started with Basic Liquidity Strategies
Advanced Liquidity Strategies on Saros
Managing Out-of-Range Liquidity on Saros
Single-Sided Liquidity Strategies on Saros
Rewards
Concentrated Incentives (CI) on Saros
Technical Design
Technical Guides
User Guides
How to Create a Pool on Saros DLMM
How to Add and Remove Liquidity on Saros DLMM
How to Swap on Saros DLMM
FAQs
SAROS AMM
SarosSwap
SarosFarm
SarosStake
SarosSnapShot
FAQs
Go to DEX
SAROS GARDEN
Introduction
How to stake on Saros Garden
How to unstake from Saros Garden
How to redeem BERRY
SAROS SWAP
How to Swap on Saros Swap
ALL ABOUT $SAROS
Saros Token ($SAROS)
INTEGRATION
Saros AMM
Saros DLMM
LEGAL
TERMS OF SERVICE
Privacy Policy
AUDITS
SarosSwap
SarosFarm & SarosStake
Saros DLMM
Saros Garden
Saros Token (\$SAROS)
OFFICIAL LINKS
Saros Community
Brand Assets
Powered by GitBook
How liquidity providers generate returns?
When and how to adjust your positions
What are some considerations when re-balancing?
Deploy Liquidity in 5 Simple Steps
Adding Liquidity: Step by Step Guide
Batch Liquidity Deployment
Removing Liquidity
Risks of Managing Liquidity
Copy

SAROS DLMM
Onboarding and Guides
Liquidity Lifecycle: Deployment, Management & Rebalancing
Contents
How liquidity providers generate returns?

When and how to adjust your positions

Step by Step Guide to deploy liquidity

Batch deployment feature (deploy any range you want)

Removing your liquidity

How liquidity providers generate returns?
When you provide liquidity with Saros DLMM, you automatically earn a share of the fees from every swap. These fees are instantly accrued and compounded into your position with no manual claiming required. It's a smooth, hands-free way to grow your earnings.

When and how to adjust your positions
To keep earning trading fees, liquidity providers must rebalance their positions when their liquidity falls outside the active range. This involves removing tokens from inactive bins and redeploying them into active bins that reflect the current market price. Saros DLMM simplifies this process by offering flexible options so you can either add to your existing position or withdraw and redeploy some or all of your liquidity with ease.

What are some considerations when re-balancing?
Costs: Rebalancing requires gas fees and may involve trading between assets, which can incur additional fees. It's important to weigh these costs when deciding how often to rebalance your position.

Market Conditions: Effective rebalancing on Saros DLMM depends on the market environment. In volatile conditions, more frequent rebalancing may be necessary to stay within the active range and maximize fee earnings.

Deploy Liquidity in 5 Simple Steps
Add liquidity in just five easy steps or keep scrolling for the detailed walkthrough.

Adding Liquidity: Step by Step Guide
Select a Liquidity Pool: On the Pools page, search for the pool you want to provide liquidity to.

Deposit Your Token: Use the panel on the right side of the pool page to enter the amount of tokens you'd like to deposit. For example, you can add SAROS and SOL.

Choose a Liquidity Shape: Select the liquidity shape that matches your strategy. If you're unsure, refer to the guide for help choosing the right option.

Supply Liquidity: Click the "Supply" button to confirm your deposit. Afterward, your liquidity details will be shown on the left side of the screen. Your selected liquidity shape will appear in the graph, and your balance will be updated accordingly.

Batch Liquidity Deployment
Deploy liquidity across ANY price range you choose. Simply select your preferred liquidity shape, input the desired price range, and use the 'Add Liquidity' option for each batch transaction.

With Batch Liquidity Deployment, you can spread your liquidity across a wider range — perfect for a more passive and diversified liquidity provisioning strategy.

Removing Liquidity
How to Remove Liquidity: 3 Flexible Options

Remove both tokens from the pool

Remove only the first token

Remove only the second token

To remove liquidity, go to the Pool page where you've provided liquidity and click "Remove Liquidity." You'll be presented with three standard options — choose the one that suits your needs and set the amount you want to withdraw (or select "Remove All" for a full exit).
Option 1: Remove both tokens from the pool

Option 2: Remove only the first/ second token

If you'd like to remove tokens from specific bins, simply input the price ranges you want to target. This advanced option gives you more control and can be useful when rebalancing your position.

Risks of Managing Liquidity
Participating as a liquidity provider on the Saros DLMM protocol involves several risks, including but not limited to: impermanent loss, smart contract vulnerabilities, systemic failures, liquidity shortages, regulatory shifts, market volatility, and operational errors. Your capital is at risk, and you should only invest funds you can afford to lose. There are no guarantees of returns, and all investment decisions are made at your own discretion. We strongly recommend seeking independent financial advice before participating.

Previous
Saros DLMM: Introduction
Next
Permissionless Saros DLMM Pools
Last updated 9 days ago

Liquidity Lifecycle: Deployment, Management & Rebalancing | Saros

Saros
Search…
⌘
K

English
SAROS
SAROS DLMM
SAROS AMM
INTEGRATION
SAROS DLMM
Onboarding and Guides
Saros DLMM: Introduction
Liquidity Lifecycle: Deployment, Management & Rebalancing
Permissionless Saros DLMM Pools
Understanding Your Risks as a Liquidity Provider on Saros DLMM
Shapes and Strategies
Liquidity Shapes
Getting Started with Basic Liquidity Strategies
Advanced Liquidity Strategies on Saros
Managing Out-of-Range Liquidity on Saros
Single-Sided Liquidity Strategies on Saros
Rewards
Concentrated Incentives (CI) on Saros
Technical Design
Technical Guides
User Guides
How to Create a Pool on Saros DLMM
How to Add and Remove Liquidity on Saros DLMM
How to Swap on Saros DLMM
FAQs
SAROS AMM
SarosSwap
SarosFarm
SarosStake
SarosSnapShot
FAQs
Go to DEX
SAROS GARDEN
Introduction
How to stake on Saros Garden
How to unstake from Saros Garden
How to redeem BERRY
SAROS SWAP
How to Swap on Saros Swap
ALL ABOUT $SAROS
Saros Token ($SAROS)
INTEGRATION
Saros AMM
Saros DLMM
LEGAL
TERMS OF SERVICE
Privacy Policy
AUDITS
SarosSwap
SarosFarm & SarosStake
Saros DLMM
Saros Garden
Saros Token (\$SAROS)
OFFICIAL LINKS
Saros Community
Brand Assets
Powered by GitBook
Creating a New Liquidity Pool with Saros DLMM
Step 1: Open a Pool
Step 2: Configure Your V2 Pool
Step 3: Finalize & Launch Your Pool
Copy

SAROS DLMM
Onboarding and Guides
Permissionless Saros DLMM Pools
In this article you can learn how to open a new liquidity pool and also understand the difference between AMM mode and DLMM model.

Creating a New Liquidity Pool with Saros DLMM
In this guide, you'll learn how to open a new liquidity pool on Saros DLMM, understand the key differences between AMM mode and DLMM model, and explore how Bin Steps (BPs) work in V2 pools.

Step 1: Open a Pool
Go to the Pool page and click "Create New Pool.

V1 vs. V2: What’s the Difference?
V1: Traditional Constant Product Pool (x\*y=k)

Maintains a 50/50 balance of both tokens across a full price curve from \$0 to ∞.

Ideal for new token listings on the DEX.

Automatically balances your assets — good for set-it-and-forget-it liquidity.

V2: Saros DLMM Pool

Allows concentrated liquidity: provide liquidity only within specific price ranges.

Significantly increases capital efficiency, but also comes with more risk and responsibility.

Requires active liquidity management to stay within range.

Step 2: Configure Your V2 Pool
When creating a V2 pool, you’ll need to:

Select Base and Quote Assets

Base Asset (Token X): The token being priced. Can be any token.

Quote Asset (Token Y): The token used to define the price, limited to major tokens like AVAX, ETH, or USDC for optimal routing and liquidity.

Set Your Bin Step (Bps)

Bins are individual price points where liquidity is concentrated.

Bin Step (Bps) defines the price gap between each bin.

Understanding Bin Steps (Bps)
Each pool is made of bins — think of them as containers holding liquidity at fixed prices. The Bin Step determines how wide or narrow the price gaps are between bins:

Example:

20 bps (0.2%)

ARB/USDC Bin 1: \$1.21464

ARB/USDC Bin 2: \$1.21707

100 bps (0.8%) over 20 bins covers a 22% price range

20 bps (0.2%) over 20 bins covers only a 4% price range

For new tokens, a higher Bin Step (wider price gaps) may simplify liquidity management and reduce the need for frequent rebalancing.

Step 3: Finalize & Launch Your Pool
Before launching:

Set the Active Market Price
This is crucial — the price you enter will be the starting point for the pool.
✅ Ensure it reflects the actual market price of the asset.
❌ Entering the wrong price can lead to arbitrage losses and unrecoverable funds.

Previous
Liquidity Lifecycle: Deployment, Management & Rebalancing
Next
Understanding Your Risks as a Liquidity Provider on Saros DLMM
Last updated 5 months ago

Permissionless Saros DLMM Pools | Saros

Saros
Search…
⌘
K

English
SAROS
SAROS DLMM
SAROS AMM
INTEGRATION
SAROS DLMM
Onboarding and Guides
Saros DLMM: Introduction
Liquidity Lifecycle: Deployment, Management & Rebalancing
Permissionless Saros DLMM Pools
Understanding Your Risks as a Liquidity Provider on Saros DLMM
Shapes and Strategies
Liquidity Shapes
Getting Started with Basic Liquidity Strategies
Advanced Liquidity Strategies on Saros
Managing Out-of-Range Liquidity on Saros
Single-Sided Liquidity Strategies on Saros
Rewards
Concentrated Incentives (CI) on Saros
Technical Design
Technical Guides
User Guides
How to Create a Pool on Saros DLMM
How to Add and Remove Liquidity on Saros DLMM
How to Swap on Saros DLMM
FAQs
SAROS AMM
SarosSwap
SarosFarm
SarosStake
SarosSnapShot
FAQs
Go to DEX
SAROS GARDEN
Introduction
How to stake on Saros Garden
How to unstake from Saros Garden
How to redeem BERRY
SAROS SWAP
How to Swap on Saros Swap
ALL ABOUT $SAROS
Saros Token ($SAROS)
INTEGRATION
Saros AMM
Saros DLMM
LEGAL
TERMS OF SERVICE
Privacy Policy
AUDITS
SarosSwap
SarosFarm & SarosStake
Saros DLMM
Saros Garden
Saros Token (\$SAROS)
OFFICIAL LINKS
Saros Community
Brand Assets
Powered by GitBook
Understanding Your Risks as a Liquidity Provider on Saros DLMM

1. Impermanent Loss (IL)
2. Out-of-Range Liquidity
3. Price Volatility
4. Smart Contract Risk
5. Protocol-Level Risks
6. Regulatory Uncertainty
7. Operational Risk
   What is Divergence Loss (Impermanent Loss)?
   Scenario 1: Price of Token A increases to $200 (Token B stays $1)
   Scenario 2: Price of Token A drops to $50 (Token B stays $1)
   Copy

SAROS DLMM
Onboarding and Guides
Understanding Your Risks as a Liquidity Provider on Saros DLMM
Understanding Your Risks as a Liquidity Provider on Saros DLMM
Providing liquidity in DeFi opens the door to earning trading fees and incentives — but like any financial strategy, it also comes with risks.

At Saros, we want to help you make informed decisions. This guide breaks down the main risks you should understand before depositing liquidity into Saros DLMM pools.

1. Impermanent Loss (IL)
   Impermanent loss occurs when the market price of the tokens in your pool moves away from your entry price. If you withdraw your liquidity after a major price shift, the value of your assets may be less than if you just held them.

It’s called “impermanent” because it only becomes real if you withdraw while prices are still misaligned.

IL can be minimized (or even reversed) if prices return to your original range — or if fees earned compensate for the divergence.

Bin-based liquidity allows you to target specific price zones, which can help reduce exposure to IL — but it doesn't eliminate it completely.

2. Out-of-Range Liquidity
   If the market moves outside the price range where your liquidity is placed, your position becomes inactive and stops earning fees.

You’ll need to:

Wait for the price to come back into range, or

Reposition your liquidity to the new active price bins

This creates a balance between passive vs. active management — tighter ranges earn more but need more maintenance.

3. Price Volatility
   DeFi markets can move fast, and tokens can be highly volatile. While this can increase trading volume (and fees), it also increases exposure to:

Impermanent loss

Sudden market swings

Pool imbalance

As an LP, you're indirectly taking on price exposure, especially if you're concentrated in a small range or single-sided.

4. Smart Contract Risk
   Saros DLMM is a smart contract system. While it's designed for security and efficiency, no smart contract is risk-free.

Potential risks include:

Bugs in the contract code

Exploits or vulnerabilities

Integration errors with third-party platforms

Always ensure you’re using verified contracts and official interfaces (like Saros’ dApp), and keep your wallet software updated.

5. Protocol-Level Risks
   Even if the contracts are safe, risks may arise at the protocol level:

Misconfigured incentives

Governance attacks

Liquidity migration events

Dependency risks (e.g., price oracles, bridges)

These can affect how rewards are distributed or how pools behave, especially in turbulent market conditions.

6. Regulatory Uncertainty
   While DeFi is global and open, regulatory changes in your country (or globally) may impact your ability to participate or affect how protocols operate in the future.

Stay informed and aware of local legal frameworks — especially when dealing with real-world assets or stablecoins.

7. Operational Risk
   Sometimes, simple user-side errors can cause problems:

Depositing into the wrong pool or range

Mistiming entry during high volatility

Forgetting to manage or withdraw liquidity

We recommend all users review their positions regularly and use Saros’ UI features like My Positions, Real-Time Rewards, and Limit Orders for better control.

What is Divergence Loss (Impermanent Loss)?
Impermanent loss happens when the price of tokens in a liquidity pool moves away from the point where you deposited liquidity. It’s “impermanent” because the loss is only realized when you withdraw — but with concentrated liquidity (like on Saros), the impact can be more noticeable if you're tightly positioned.

Setup:
Let’s say:

Token A = \$100

Token B = \$1

You provide \$1000 in liquidity as 5 Token A + 500 Token B

Your liquidity is placed in a tight range (e.g., $99.9 to $100.1)

Scenario 1: Price of Token A increases to $200 (Token B stays $1)
Strategy

Token A

Token B

Total Value

Impermanent Loss

Holding

5

500

\$1500

0%

Saros AMM

3.54

707.11

\$1414.21

5.7%

Saros DLMM

0

1000

\$1000

33.3%

Because you were in a concentrated range and didn’t adjust, all of your Token A got swapped into Token B before the price pumped → lower ending value.

Scenario 2: Price of Token A drops to $50 (Token B stays $1)
Strategy

Token A

Token B

Total Value

Impermanent Loss

Holding

5

500

\$750

0%

Saros AMM

7.07

353.55

\$707.11

5.7%

Saros DLMM

10

0

\$500

33.3%

This time, your entire position got swapped into Token A as the price dropped. If you withdraw now, you lock in a lower value than if you had simply held both tokens.

Key Takeaways
Concentrated Liquidity = Higher Risk, Higher Reward
You can earn more fees, but you’re also more exposed to price divergence;

Wider ranges reduce divergence loss, but they may earn fewer fees;

Active LPs should monitor positions and rebalance when the price leaves the active range.

Previous
Permissionless Saros DLMM Pools
Next
Shapes and Strategies
Last updated 5 months ago

Understanding Your Risks as a Liquidity Provider on Saros DLMM | Saros

Saros
Search…
⌘
K

English
SAROS
SAROS DLMM
SAROS AMM
INTEGRATION
SAROS DLMM
Onboarding and Guides
Saros DLMM: Introduction
Liquidity Lifecycle: Deployment, Management & Rebalancing
Permissionless Saros DLMM Pools
Understanding Your Risks as a Liquidity Provider on Saros DLMM
Shapes and Strategies
Liquidity Shapes
Getting Started with Basic Liquidity Strategies
Advanced Liquidity Strategies on Saros
Managing Out-of-Range Liquidity on Saros
Single-Sided Liquidity Strategies on Saros
Rewards
Concentrated Incentives (CI) on Saros
Technical Design
Technical Guides
User Guides
How to Create a Pool on Saros DLMM
How to Add and Remove Liquidity on Saros DLMM
How to Swap on Saros DLMM
FAQs
SAROS AMM
SarosSwap
SarosFarm
SarosStake
SarosSnapShot
FAQs
Go to DEX
SAROS GARDEN
Introduction
How to stake on Saros Garden
How to unstake from Saros Garden
How to redeem BERRY
SAROS SWAP
How to Swap on Saros Swap
ALL ABOUT $SAROS
Saros Token ($SAROS)
INTEGRATION
Saros AMM
Saros DLMM
LEGAL
TERMS OF SERVICE
Privacy Policy
AUDITS
SarosSwap
SarosFarm & SarosStake
Saros DLMM
Saros Garden
Saros Token (\$SAROS)
OFFICIAL LINKS
Saros Community
Brand Assets
Powered by GitBook
I. Introduction to Liquidity Shapes
II. How to Earn Fees
III. The Types of Shapes and Strategies
Basic Strategies
Advanced Strategies
Single-Sided Strategies
IV. Understanding the Risks
Copy

SAROS DLMM
Shapes and Strategies
Liquidity Shapes
What you’ll learn:

Introduction to Liquidity Shapes

Spot

Curve

Bid-ask

How to earn fees using a Shape

The types of Shapes and Strategies

Your Risks

I. Introduction to Liquidity Shapes
This guide is tailored to help you get the most out of the Saros DLMM as deployed on Saros DLMM. At the core of this system is the concept of Liquidity Shapes—customizable strategies that allow you to decide how and where your capital is allocated across different price points. This flexibility empowers your funds to work smarter, enabling you to optimize returns based on your personal strategy and market expectations.

The secret behind Liquidity Shapes is the bin-based architecture. Unlike traditional AMMs, which spread your liquidity evenly, Saros DLMM lets you choose exactly where to place your funds by using "bins."

“What is a bin?
A bin is a fixed-price segment in a Saros DLMM pool. Each bin corresponds to a specific price point. When you add liquidity to a bin, your funds are active only at that price level. Traders interact with your liquidity when the market trades within that bin's range—earning you fees in the process.”

By combining and customizing bins, you create a Liquidity Shape that matches your market outlook, risk tolerance, and strategy. There’s no “one-size-fits-all” approach—each shape has its own strengths depending on how and when it’s used.

Let’s explore the three core Liquidity Shapes:

1.1 Spot Shape
Structure:

Spot shape distributes liquidity uniformly across your selected price range. This means every price point within the range gets equal liquidity, offering a balanced, straightforward setup.

Ideal For:

Stable or low-volatility tokens

Traders who expect the price to hover near a specific level

Quick, efficient trades at the market price

Why Use It:

It’s a reliable all-around option for maintaining consistent exposure across a range. Spot shape is simple yet effective, particularly when you want a passive strategy with even risk distribution.

1.2 Curve Shape
Structure:

Curve shape concentrates most of your liquidity around the central point of your range, gradually tapering off toward the edges. This forms a bell-curve-like distribution, maximizing capital efficiency near the expected price.

Ideal For:

Pairs with low to moderate volatility

Long-term liquidity providers

Sideways or range-bound markets

Why Use It:

Perfect for passive LPs looking to stay in-range longer while optimizing returns. Curve shape offers a smart balance between exposure and efficiency, reducing the need for frequent repositioning.

1.3 Bid-Ask Shape
Structure:

The Bid-Ask shape places liquidity at both ends of your selected range, leaving the middle relatively empty. It resembles an inverted curve or order book, focusing on price extremes.

Ideal For:

Volatile or swing-trading environments

Stable or pegged pairs with sudden deviations

Traders aiming to buy low and sell high over time

Why Use It:

This setup is tactical and reactive. By concentrating liquidity on the outer edges, it’s well-suited for earning fees during volatility or for gradually accumulating/distributing positions during swings.

II. How to Earn Fees
As an LP, you earn trading fees when users swap tokens in the bins where your liquidity is active. The more trading activity in your bins, the more fees you collect. Here’s how to get the most from your liquidity:

Stay in Active Bins: You only earn fees when trades occur in the bins you’ve chosen. Position your liquidity where trading volume is highest.

Adjust with the Market: Markets shift—so should your strategy. Monitor your shapes and move them as needed to stay relevant.

Match Shape to Conditions:

Spot Shape for stable prices

Curve Shape for sideways or range-bound markets

Bid-Ask Shape for high-volatility situations

With Liquidity Shapes, you control where your funds are used—so you can focus your capital where it works hardest.

III. The Types of Shapes and Strategies
Whether you’re just starting out or looking to fine-tune advanced strategies, Saros DLMM supports a wide range of liquidity deployments. Here's a breakdown:

Basic Strategies
Designed for ease-of-use, these are ideal for users who are new to Saros DLMM or concentrated liquidity:

Passive Curve: A smooth distribution across a price range. Easy to set, low maintenance.

Tight Spot: Narrow deployment around a stable price. Great for active monitoring.

Entry/Exit Spot: Use a narrow shape to gradually buy or sell into a token.

Advanced Strategies
For more experienced users looking to customize deeply and control risk/reward:

Split Shapes: Combine bid-side and ask-side liquidity to profit from price swings.

Staggered Curves: Layered deployments for covering breakout zones.

Automated Rebalancing: Use bots or external tools to adjust shapes in real time based on volatility or indicators.

Single-Sided Strategies
Target just one side of the market:

Buy-side Liquidity: Accumulate a token when price dips.

Sell-side Liquidity: Exit your position as the price increases.

These are highly effective for efficient entries and exits—especially when paired with the right shape.

IV. Understanding the Risks
Participating in liquidity provision—regardless of strategy—comes with inherent risks. These include, but are not limited to:

Impermanent Loss (IL) when asset prices diverge

Smart contract vulnerabilities

Systemic or platform-related failures

Market volatility and liquidity crunches

Regulatory shifts

Human or operational errors

There are no guarantees in DeFi, and you should only provide liquidity with capital you can afford to lose. If you're unsure, always seek advice from a qualified financial professional.

Previous
Shapes and Strategies
Next
Getting Started with Basic Liquidity Strategies
Last updated 5 months ago

Liquidity Shapes | Saros

Saros
Search…
⌘
K

English
SAROS
SAROS DLMM
SAROS AMM
INTEGRATION
SAROS DLMM
Onboarding and Guides
Saros DLMM: Introduction
Liquidity Lifecycle: Deployment, Management & Rebalancing
Permissionless Saros DLMM Pools
Understanding Your Risks as a Liquidity Provider on Saros DLMM
Shapes and Strategies
Liquidity Shapes
Getting Started with Basic Liquidity Strategies
Advanced Liquidity Strategies on Saros
Managing Out-of-Range Liquidity on Saros
Single-Sided Liquidity Strategies on Saros
Rewards
Concentrated Incentives (CI) on Saros
Technical Design
Technical Guides
User Guides
How to Create a Pool on Saros DLMM
How to Add and Remove Liquidity on Saros DLMM
How to Swap on Saros DLMM
FAQs
SAROS AMM
SarosSwap
SarosFarm
SarosStake
SarosSnapShot
FAQs
Go to DEX
SAROS GARDEN
Introduction
How to stake on Saros Garden
How to unstake from Saros Garden
How to redeem BERRY
SAROS SWAP
How to Swap on Saros Swap
ALL ABOUT $SAROS
Saros Token ($SAROS)
INTEGRATION
Saros AMM
Saros DLMM
LEGAL
TERMS OF SERVICE
Privacy Policy
AUDITS
SarosSwap
SarosFarm & SarosStake
Saros DLMM
Saros Garden
Saros Token (\$SAROS)
OFFICIAL LINKS
Saros Community
Brand Assets
Powered by GitBook
I. Introduction to Liquidity Shapes
II. How to Earn Fees
III. The Types of Shapes and Strategies
Basic Strategies
Advanced Strategies
Single-Sided Strategies
IV. Understanding the Risks
Copy

SAROS DLMM
Shapes and Strategies
Liquidity Shapes
What you’ll learn:

Introduction to Liquidity Shapes

Spot

Curve

Bid-ask

How to earn fees using a Shape

The types of Shapes and Strategies

Your Risks

I. Introduction to Liquidity Shapes
This guide is tailored to help you get the most out of the Saros DLMM as deployed on Saros DLMM. At the core of this system is the concept of Liquidity Shapes—customizable strategies that allow you to decide how and where your capital is allocated across different price points. This flexibility empowers your funds to work smarter, enabling you to optimize returns based on your personal strategy and market expectations.

The secret behind Liquidity Shapes is the bin-based architecture. Unlike traditional AMMs, which spread your liquidity evenly, Saros DLMM lets you choose exactly where to place your funds by using "bins."

“What is a bin?
A bin is a fixed-price segment in a Saros DLMM pool. Each bin corresponds to a specific price point. When you add liquidity to a bin, your funds are active only at that price level. Traders interact with your liquidity when the market trades within that bin's range—earning you fees in the process.”

By combining and customizing bins, you create a Liquidity Shape that matches your market outlook, risk tolerance, and strategy. There’s no “one-size-fits-all” approach—each shape has its own strengths depending on how and when it’s used.

Let’s explore the three core Liquidity Shapes:

1.1 Spot Shape
Structure:

Spot shape distributes liquidity uniformly across your selected price range. This means every price point within the range gets equal liquidity, offering a balanced, straightforward setup.

Ideal For:

Stable or low-volatility tokens

Traders who expect the price to hover near a specific level

Quick, efficient trades at the market price

Why Use It:

It’s a reliable all-around option for maintaining consistent exposure across a range. Spot shape is simple yet effective, particularly when you want a passive strategy with even risk distribution.

1.2 Curve Shape
Structure:

Curve shape concentrates most of your liquidity around the central point of your range, gradually tapering off toward the edges. This forms a bell-curve-like distribution, maximizing capital efficiency near the expected price.

Ideal For:

Pairs with low to moderate volatility

Long-term liquidity providers

Sideways or range-bound markets

Why Use It:

Perfect for passive LPs looking to stay in-range longer while optimizing returns. Curve shape offers a smart balance between exposure and efficiency, reducing the need for frequent repositioning.

1.3 Bid-Ask Shape
Structure:

The Bid-Ask shape places liquidity at both ends of your selected range, leaving the middle relatively empty. It resembles an inverted curve or order book, focusing on price extremes.

Ideal For:

Volatile or swing-trading environments

Stable or pegged pairs with sudden deviations

Traders aiming to buy low and sell high over time

Why Use It:

This setup is tactical and reactive. By concentrating liquidity on the outer edges, it’s well-suited for earning fees during volatility or for gradually accumulating/distributing positions during swings.

II. How to Earn Fees
As an LP, you earn trading fees when users swap tokens in the bins where your liquidity is active. The more trading activity in your bins, the more fees you collect. Here’s how to get the most from your liquidity:

Stay in Active Bins: You only earn fees when trades occur in the bins you’ve chosen. Position your liquidity where trading volume is highest.

Adjust with the Market: Markets shift—so should your strategy. Monitor your shapes and move them as needed to stay relevant.

Match Shape to Conditions:

Spot Shape for stable prices

Curve Shape for sideways or range-bound markets

Bid-Ask Shape for high-volatility situations

With Liquidity Shapes, you control where your funds are used—so you can focus your capital where it works hardest.

III. The Types of Shapes and Strategies
Whether you’re just starting out or looking to fine-tune advanced strategies, Saros DLMM supports a wide range of liquidity deployments. Here's a breakdown:

Basic Strategies
Designed for ease-of-use, these are ideal for users who are new to Saros DLMM or concentrated liquidity:

Passive Curve: A smooth distribution across a price range. Easy to set, low maintenance.

Tight Spot: Narrow deployment around a stable price. Great for active monitoring.

Entry/Exit Spot: Use a narrow shape to gradually buy or sell into a token.

Advanced Strategies
For more experienced users looking to customize deeply and control risk/reward:

Split Shapes: Combine bid-side and ask-side liquidity to profit from price swings.

Staggered Curves: Layered deployments for covering breakout zones.

Automated Rebalancing: Use bots or external tools to adjust shapes in real time based on volatility or indicators.

Single-Sided Strategies
Target just one side of the market:

Buy-side Liquidity: Accumulate a token when price dips.

Sell-side Liquidity: Exit your position as the price increases.

These are highly effective for efficient entries and exits—especially when paired with the right shape.

IV. Understanding the Risks
Participating in liquidity provision—regardless of strategy—comes with inherent risks. These include, but are not limited to:

Impermanent Loss (IL) when asset prices diverge

Smart contract vulnerabilities

Systemic or platform-related failures

Market volatility and liquidity crunches

Regulatory shifts

Human or operational errors

There are no guarantees in DeFi, and you should only provide liquidity with capital you can afford to lose. If you're unsure, always seek advice from a qualified financial professional.

Previous
Shapes and Strategies
Next
Getting Started with Basic Liquidity Strategies
Last updated 5 months ago

Liquidity Shapes | Saros

Saros
Search…
⌘
K

English
SAROS
SAROS DLMM
SAROS AMM
INTEGRATION
SAROS DLMM
Onboarding and Guides
Saros DLMM: Introduction
Liquidity Lifecycle: Deployment, Management & Rebalancing
Permissionless Saros DLMM Pools
Understanding Your Risks as a Liquidity Provider on Saros DLMM
Shapes and Strategies
Liquidity Shapes
Getting Started with Basic Liquidity Strategies
Advanced Liquidity Strategies on Saros
Managing Out-of-Range Liquidity on Saros
Single-Sided Liquidity Strategies on Saros
Rewards
Concentrated Incentives (CI) on Saros
Technical Design
Technical Guides
User Guides
How to Create a Pool on Saros DLMM
How to Add and Remove Liquidity on Saros DLMM
How to Swap on Saros DLMM
FAQs
SAROS AMM
SarosSwap
SarosFarm
SarosStake
SarosSnapShot
FAQs
Go to DEX
SAROS GARDEN
Introduction
How to stake on Saros Garden
How to unstake from Saros Garden
How to redeem BERRY
SAROS SWAP
How to Swap on Saros Swap
ALL ABOUT $SAROS
Saros Token ($SAROS)
INTEGRATION
Saros AMM
Saros DLMM
LEGAL
TERMS OF SERVICE
Privacy Policy
AUDITS
SarosSwap
SarosFarm & SarosStake
Saros DLMM
Saros Garden
Saros Token (\$SAROS)
OFFICIAL LINKS
Saros Community
Brand Assets
Powered by GitBook
I. Introduction to Liquidity Shapes
II. How to Earn Fees
III. The Types of Shapes and Strategies
Basic Strategies
Advanced Strategies
Single-Sided Strategies
IV. Understanding the Risks
Copy

SAROS DLMM
Shapes and Strategies
Liquidity Shapes
What you’ll learn:

Introduction to Liquidity Shapes

Spot

Curve

Bid-ask

How to earn fees using a Shape

The types of Shapes and Strategies

Your Risks

I. Introduction to Liquidity Shapes
This guide is tailored to help you get the most out of the Saros DLMM as deployed on Saros DLMM. At the core of this system is the concept of Liquidity Shapes—customizable strategies that allow you to decide how and where your capital is allocated across different price points. This flexibility empowers your funds to work smarter, enabling you to optimize returns based on your personal strategy and market expectations.

The secret behind Liquidity Shapes is the bin-based architecture. Unlike traditional AMMs, which spread your liquidity evenly, Saros DLMM lets you choose exactly where to place your funds by using "bins."

“What is a bin?
A bin is a fixed-price segment in a Saros DLMM pool. Each bin corresponds to a specific price point. When you add liquidity to a bin, your funds are active only at that price level. Traders interact with your liquidity when the market trades within that bin's range—earning you fees in the process.”

By combining and customizing bins, you create a Liquidity Shape that matches your market outlook, risk tolerance, and strategy. There’s no “one-size-fits-all” approach—each shape has its own strengths depending on how and when it’s used.

Let’s explore the three core Liquidity Shapes:

1.1 Spot Shape
Structure:

Spot shape distributes liquidity uniformly across your selected price range. This means every price point within the range gets equal liquidity, offering a balanced, straightforward setup.

Ideal For:

Stable or low-volatility tokens

Traders who expect the price to hover near a specific level

Quick, efficient trades at the market price

Why Use It:

It’s a reliable all-around option for maintaining consistent exposure across a range. Spot shape is simple yet effective, particularly when you want a passive strategy with even risk distribution.

1.2 Curve Shape
Structure:

Curve shape concentrates most of your liquidity around the central point of your range, gradually tapering off toward the edges. This forms a bell-curve-like distribution, maximizing capital efficiency near the expected price.

Ideal For:

Pairs with low to moderate volatility

Long-term liquidity providers

Sideways or range-bound markets

Why Use It:

Perfect for passive LPs looking to stay in-range longer while optimizing returns. Curve shape offers a smart balance between exposure and efficiency, reducing the need for frequent repositioning.

1.3 Bid-Ask Shape
Structure:

The Bid-Ask shape places liquidity at both ends of your selected range, leaving the middle relatively empty. It resembles an inverted curve or order book, focusing on price extremes.

Ideal For:

Volatile or swing-trading environments

Stable or pegged pairs with sudden deviations

Traders aiming to buy low and sell high over time

Why Use It:

This setup is tactical and reactive. By concentrating liquidity on the outer edges, it’s well-suited for earning fees during volatility or for gradually accumulating/distributing positions during swings.

II. How to Earn Fees
As an LP, you earn trading fees when users swap tokens in the bins where your liquidity is active. The more trading activity in your bins, the more fees you collect. Here’s how to get the most from your liquidity:

Stay in Active Bins: You only earn fees when trades occur in the bins you’ve chosen. Position your liquidity where trading volume is highest.

Adjust with the Market: Markets shift—so should your strategy. Monitor your shapes and move them as needed to stay relevant.

Match Shape to Conditions:

Spot Shape for stable prices

Curve Shape for sideways or range-bound markets

Bid-Ask Shape for high-volatility situations

With Liquidity Shapes, you control where your funds are used—so you can focus your capital where it works hardest.

III. The Types of Shapes and Strategies
Whether you’re just starting out or looking to fine-tune advanced strategies, Saros DLMM supports a wide range of liquidity deployments. Here's a breakdown:

Basic Strategies
Designed for ease-of-use, these are ideal for users who are new to Saros DLMM or concentrated liquidity:

Passive Curve: A smooth distribution across a price range. Easy to set, low maintenance.

Tight Spot: Narrow deployment around a stable price. Great for active monitoring.

Entry/Exit Spot: Use a narrow shape to gradually buy or sell into a token.

Advanced Strategies
For more experienced users looking to customize deeply and control risk/reward:

Split Shapes: Combine bid-side and ask-side liquidity to profit from price swings.

Staggered Curves: Layered deployments for covering breakout zones.

Automated Rebalancing: Use bots or external tools to adjust shapes in real time based on volatility or indicators.

Single-Sided Strategies
Target just one side of the market:

Buy-side Liquidity: Accumulate a token when price dips.

Sell-side Liquidity: Exit your position as the price increases.

These are highly effective for efficient entries and exits—especially when paired with the right shape.

IV. Understanding the Risks
Participating in liquidity provision—regardless of strategy—comes with inherent risks. These include, but are not limited to:

Impermanent Loss (IL) when asset prices diverge

Smart contract vulnerabilities

Systemic or platform-related failures

Market volatility and liquidity crunches

Regulatory shifts

Human or operational errors

There are no guarantees in DeFi, and you should only provide liquidity with capital you can afford to lose. If you're unsure, always seek advice from a qualified financial professional.

Previous
Shapes and Strategies
Next
Getting Started with Basic Liquidity Strategies
Last updated 5 months ago

Liquidity Shapes | Saros

Saros
Search…
⌘
K

English
SAROS
SAROS DLMM
SAROS AMM
INTEGRATION
SAROS DLMM
Onboarding and Guides
Saros DLMM: Introduction
Liquidity Lifecycle: Deployment, Management & Rebalancing
Permissionless Saros DLMM Pools
Understanding Your Risks as a Liquidity Provider on Saros DLMM
Shapes and Strategies
Liquidity Shapes
Getting Started with Basic Liquidity Strategies
Advanced Liquidity Strategies on Saros
Managing Out-of-Range Liquidity on Saros
Single-Sided Liquidity Strategies on Saros
Rewards
Concentrated Incentives (CI) on Saros
Technical Design
Technical Guides
User Guides
How to Create a Pool on Saros DLMM
How to Add and Remove Liquidity on Saros DLMM
How to Swap on Saros DLMM
FAQs
SAROS AMM
SarosSwap
SarosFarm
SarosStake
SarosSnapShot
FAQs
Go to DEX
SAROS GARDEN
Introduction
How to stake on Saros Garden
How to unstake from Saros Garden
How to redeem BERRY
SAROS SWAP
How to Swap on Saros Swap
ALL ABOUT $SAROS
Saros Token ($SAROS)
INTEGRATION
Saros AMM
Saros DLMM
LEGAL
TERMS OF SERVICE
Privacy Policy
AUDITS
SarosSwap
SarosFarm & SarosStake
Saros DLMM
Saros Garden
Saros Token (\$SAROS)
OFFICIAL LINKS
Saros Community
Brand Assets
Powered by GitBook
I. Introduction to Liquidity Shapes
II. How to Earn Fees
III. The Types of Shapes and Strategies
Basic Strategies
Advanced Strategies
Single-Sided Strategies
IV. Understanding the Risks
Copy

SAROS DLMM
Shapes and Strategies
Liquidity Shapes
What you’ll learn:

Introduction to Liquidity Shapes

Spot

Curve

Bid-ask

How to earn fees using a Shape

The types of Shapes and Strategies

Your Risks

I. Introduction to Liquidity Shapes
This guide is tailored to help you get the most out of the Saros DLMM as deployed on Saros DLMM. At the core of this system is the concept of Liquidity Shapes—customizable strategies that allow you to decide how and where your capital is allocated across different price points. This flexibility empowers your funds to work smarter, enabling you to optimize returns based on your personal strategy and market expectations.

The secret behind Liquidity Shapes is the bin-based architecture. Unlike traditional AMMs, which spread your liquidity evenly, Saros DLMM lets you choose exactly where to place your funds by using "bins."

“What is a bin?
A bin is a fixed-price segment in a Saros DLMM pool. Each bin corresponds to a specific price point. When you add liquidity to a bin, your funds are active only at that price level. Traders interact with your liquidity when the market trades within that bin's range—earning you fees in the process.”

By combining and customizing bins, you create a Liquidity Shape that matches your market outlook, risk tolerance, and strategy. There’s no “one-size-fits-all” approach—each shape has its own strengths depending on how and when it’s used.

Let’s explore the three core Liquidity Shapes:

1.1 Spot Shape
Structure:

Spot shape distributes liquidity uniformly across your selected price range. This means every price point within the range gets equal liquidity, offering a balanced, straightforward setup.

Ideal For:

Stable or low-volatility tokens

Traders who expect the price to hover near a specific level

Quick, efficient trades at the market price

Why Use It:

It’s a reliable all-around option for maintaining consistent exposure across a range. Spot shape is simple yet effective, particularly when you want a passive strategy with even risk distribution.

1.2 Curve Shape
Structure:

Curve shape concentrates most of your liquidity around the central point of your range, gradually tapering off toward the edges. This forms a bell-curve-like distribution, maximizing capital efficiency near the expected price.

Ideal For:

Pairs with low to moderate volatility

Long-term liquidity providers

Sideways or range-bound markets

Why Use It:

Perfect for passive LPs looking to stay in-range longer while optimizing returns. Curve shape offers a smart balance between exposure and efficiency, reducing the need for frequent repositioning.

1.3 Bid-Ask Shape
Structure:

The Bid-Ask shape places liquidity at both ends of your selected range, leaving the middle relatively empty. It resembles an inverted curve or order book, focusing on price extremes.

Ideal For:

Volatile or swing-trading environments

Stable or pegged pairs with sudden deviations

Traders aiming to buy low and sell high over time

Why Use It:

This setup is tactical and reactive. By concentrating liquidity on the outer edges, it’s well-suited for earning fees during volatility or for gradually accumulating/distributing positions during swings.

II. How to Earn Fees
As an LP, you earn trading fees when users swap tokens in the bins where your liquidity is active. The more trading activity in your bins, the more fees you collect. Here’s how to get the most from your liquidity:

Stay in Active Bins: You only earn fees when trades occur in the bins you’ve chosen. Position your liquidity where trading volume is highest.

Adjust with the Market: Markets shift—so should your strategy. Monitor your shapes and move them as needed to stay relevant.

Match Shape to Conditions:

Spot Shape for stable prices

Curve Shape for sideways or range-bound markets

Bid-Ask Shape for high-volatility situations

With Liquidity Shapes, you control where your funds are used—so you can focus your capital where it works hardest.

III. The Types of Shapes and Strategies
Whether you’re just starting out or looking to fine-tune advanced strategies, Saros DLMM supports a wide range of liquidity deployments. Here's a breakdown:

Basic Strategies
Designed for ease-of-use, these are ideal for users who are new to Saros DLMM or concentrated liquidity:

Passive Curve: A smooth distribution across a price range. Easy to set, low maintenance.

Tight Spot: Narrow deployment around a stable price. Great for active monitoring.

Entry/Exit Spot: Use a narrow shape to gradually buy or sell into a token.

Advanced Strategies
For more experienced users looking to customize deeply and control risk/reward:

Split Shapes: Combine bid-side and ask-side liquidity to profit from price swings.

Staggered Curves: Layered deployments for covering breakout zones.

Automated Rebalancing: Use bots or external tools to adjust shapes in real time based on volatility or indicators.

Single-Sided Strategies
Target just one side of the market:

Buy-side Liquidity: Accumulate a token when price dips.

Sell-side Liquidity: Exit your position as the price increases.

These are highly effective for efficient entries and exits—especially when paired with the right shape.

IV. Understanding the Risks
Participating in liquidity provision—regardless of strategy—comes with inherent risks. These include, but are not limited to:

Impermanent Loss (IL) when asset prices diverge

Smart contract vulnerabilities

Systemic or platform-related failures

Market volatility and liquidity crunches

Regulatory shifts

Human or operational errors

There are no guarantees in DeFi, and you should only provide liquidity with capital you can afford to lose. If you're unsure, always seek advice from a qualified financial professional.

Previous
Shapes and Strategies
Next
Getting Started with Basic Liquidity Strategies
Last updated 5 months ago

Liquidity Shapes | Saros

Saros
Search…
⌘
K

English
SAROS
SAROS DLMM
SAROS AMM
INTEGRATION
SAROS DLMM
Onboarding and Guides
Saros DLMM: Introduction
Liquidity Lifecycle: Deployment, Management & Rebalancing
Permissionless Saros DLMM Pools
Understanding Your Risks as a Liquidity Provider on Saros DLMM
Shapes and Strategies
Liquidity Shapes
Getting Started with Basic Liquidity Strategies
Advanced Liquidity Strategies on Saros
Managing Out-of-Range Liquidity on Saros
Single-Sided Liquidity Strategies on Saros
Rewards
Concentrated Incentives (CI) on Saros
Technical Design
Technical Guides
User Guides
How to Create a Pool on Saros DLMM
How to Add and Remove Liquidity on Saros DLMM
How to Swap on Saros DLMM
FAQs
SAROS AMM
SarosSwap
SarosFarm
SarosStake
SarosSnapShot
FAQs
Go to DEX
SAROS GARDEN
Introduction
How to stake on Saros Garden
How to unstake from Saros Garden
How to redeem BERRY
SAROS SWAP
How to Swap on Saros Swap
ALL ABOUT $SAROS
Saros Token ($SAROS)
INTEGRATION
Saros AMM
Saros DLMM
LEGAL
TERMS OF SERVICE
Privacy Policy
AUDITS
SarosSwap
SarosFarm & SarosStake
Saros DLMM
Saros Garden
Saros Token (\$SAROS)
OFFICIAL LINKS
Saros Community
Brand Assets
Powered by GitBook
I. Introduction to Liquidity Shapes
II. How to Earn Fees
III. The Types of Shapes and Strategies
Basic Strategies
Advanced Strategies
Single-Sided Strategies
IV. Understanding the Risks
Copy

SAROS DLMM
Shapes and Strategies
Liquidity Shapes
What you’ll learn:

Introduction to Liquidity Shapes

Spot

Curve

Bid-ask

How to earn fees using a Shape

The types of Shapes and Strategies

Your Risks

I. Introduction to Liquidity Shapes
This guide is tailored to help you get the most out of the Saros DLMM as deployed on Saros DLMM. At the core of this system is the concept of Liquidity Shapes—customizable strategies that allow you to decide how and where your capital is allocated across different price points. This flexibility empowers your funds to work smarter, enabling you to optimize returns based on your personal strategy and market expectations.

The secret behind Liquidity Shapes is the bin-based architecture. Unlike traditional AMMs, which spread your liquidity evenly, Saros DLMM lets you choose exactly where to place your funds by using "bins."

“What is a bin?
A bin is a fixed-price segment in a Saros DLMM pool. Each bin corresponds to a specific price point. When you add liquidity to a bin, your funds are active only at that price level. Traders interact with your liquidity when the market trades within that bin's range—earning you fees in the process.”

By combining and customizing bins, you create a Liquidity Shape that matches your market outlook, risk tolerance, and strategy. There’s no “one-size-fits-all” approach—each shape has its own strengths depending on how and when it’s used.

Let’s explore the three core Liquidity Shapes:

1.1 Spot Shape
Structure:

Spot shape distributes liquidity uniformly across your selected price range. This means every price point within the range gets equal liquidity, offering a balanced, straightforward setup.

Ideal For:

Stable or low-volatility tokens

Traders who expect the price to hover near a specific level

Quick, efficient trades at the market price

Why Use It:

It’s a reliable all-around option for maintaining consistent exposure across a range. Spot shape is simple yet effective, particularly when you want a passive strategy with even risk distribution.

1.2 Curve Shape
Structure:

Curve shape concentrates most of your liquidity around the central point of your range, gradually tapering off toward the edges. This forms a bell-curve-like distribution, maximizing capital efficiency near the expected price.

Ideal For:

Pairs with low to moderate volatility

Long-term liquidity providers

Sideways or range-bound markets

Why Use It:

Perfect for passive LPs looking to stay in-range longer while optimizing returns. Curve shape offers a smart balance between exposure and efficiency, reducing the need for frequent repositioning.

1.3 Bid-Ask Shape
Structure:

The Bid-Ask shape places liquidity at both ends of your selected range, leaving the middle relatively empty. It resembles an inverted curve or order book, focusing on price extremes.

Ideal For:

Volatile or swing-trading environments

Stable or pegged pairs with sudden deviations

Traders aiming to buy low and sell high over time

Why Use It:

This setup is tactical and reactive. By concentrating liquidity on the outer edges, it’s well-suited for earning fees during volatility or for gradually accumulating/distributing positions during swings.

II. How to Earn Fees
As an LP, you earn trading fees when users swap tokens in the bins where your liquidity is active. The more trading activity in your bins, the more fees you collect. Here’s how to get the most from your liquidity:

Stay in Active Bins: You only earn fees when trades occur in the bins you’ve chosen. Position your liquidity where trading volume is highest.

Adjust with the Market: Markets shift—so should your strategy. Monitor your shapes and move them as needed to stay relevant.

Match Shape to Conditions:

Spot Shape for stable prices

Curve Shape for sideways or range-bound markets

Bid-Ask Shape for high-volatility situations

With Liquidity Shapes, you control where your funds are used—so you can focus your capital where it works hardest.

III. The Types of Shapes and Strategies
Whether you’re just starting out or looking to fine-tune advanced strategies, Saros DLMM supports a wide range of liquidity deployments. Here's a breakdown:

Basic Strategies
Designed for ease-of-use, these are ideal for users who are new to Saros DLMM or concentrated liquidity:

Passive Curve: A smooth distribution across a price range. Easy to set, low maintenance.

Tight Spot: Narrow deployment around a stable price. Great for active monitoring.

Entry/Exit Spot: Use a narrow shape to gradually buy or sell into a token.

Advanced Strategies
For more experienced users looking to customize deeply and control risk/reward:

Split Shapes: Combine bid-side and ask-side liquidity to profit from price swings.

Staggered Curves: Layered deployments for covering breakout zones.

Automated Rebalancing: Use bots or external tools to adjust shapes in real time based on volatility or indicators.

Single-Sided Strategies
Target just one side of the market:

Buy-side Liquidity: Accumulate a token when price dips.

Sell-side Liquidity: Exit your position as the price increases.

These are highly effective for efficient entries and exits—especially when paired with the right shape.

IV. Understanding the Risks
Participating in liquidity provision—regardless of strategy—comes with inherent risks. These include, but are not limited to:

Impermanent Loss (IL) when asset prices diverge

Smart contract vulnerabilities

Systemic or platform-related failures

Market volatility and liquidity crunches

Regulatory shifts

Human or operational errors

There are no guarantees in DeFi, and you should only provide liquidity with capital you can afford to lose. If you're unsure, always seek advice from a qualified financial professional.

Previous
Shapes and Strategies
Next
Getting Started with Basic Liquidity Strategies
Last updated 5 months ago

Liquidity Shapes | Saros

# Technical Design

### Intro

Saros DLMM runs on Liquidity Book (courtesy of LFJ).&#x20;

Liquidity Book core enables the creation of unique and dynamic liquidity structures for a paired asset market, as liquidity is pooled in constant price bins which are aggregated to establish a market.

The mechanism makes it fast and seamless for anyone to trade directly on Solana - no middlemen, just pure DeFi power.

### 1. Concentrated Liquidity&#x20;

Uniswap v3 introduced concentrated liquidity, allowing liquidity providers to allocate reserves within specific price ranges, aggregated via a constant function formula.&#x20;

Curve v1 and v2 similarly concentrate liquidity around a peg price, with v2 using a dynamic peg via an internal price oracle.&#x20;

In general, these constant function models limit tailored market-making strategies.

### 2. Liquidity Book

The Liquidity Book (LB) organizes liquidity for an asset pair into discrete price bins, where deposited reserves are traded at each bin's fixed exchange rate. The market is formed by combining all these bins, with liquidity contributions from various participants.\\

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXezUpiVy8SSfQHszyJkWRA8VpIgawQpG30JTzjRXzVPH6yBVarjs36mBC7qKlCYtzvHdv-foLZ3UANpHCe-BNKlPXwtGbmWQ_qyM7UBhUoR6yGsq5ELW2_hqzlLG3XlPwny-uAKbg?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption><p>Liquidity Structure Example</p></figcaption></figure>

Let’s take a deeper look into the design.

### Liquidity Book Design

#### 1. Reserve Pricing&#x20;

Following AMM convention, price (P) is defined as the rate of change in Y reserves per change in X reserves. Price represents the value of the base asset (X) denominated in the quote asset (Y) terms.&#x20;

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXeQHrP9t1RVtyQBOJfaaWbh9EhgFPZvMQalhKtOyvRgDbDc6JuI6SD7PJjbMINNuwmCU4_ttm_3EywcS9orO0yVciM7uTMlleTQvx7pNtqNs0zr2FSoxtsnjOPt191pMKPgQkVHxQ?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

#### 2. Bin Liquidity

Liquidity (L) is the nominal value of reserves in a discrete bin, denominated in the quoted asset, and conserved as reserve composition changes.\
Liquidity (L) is defined to be the nominal value of reserves deposited into a discrete bin and is denominated in the quote asset. Liquidity is conserved as the bin’s reserve composition changes and can be described in Eq 2.2 as the value sum of its composite assets.&#x20;

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXfJ0cPtKJwKlcjIhyvHio_qQRhQygOvtFA1994XkjTttbJwdVG10TsYtHr6DMRFuWKVAbz82VpVujoN3euAIWLXrLTjqiypEaDzfjTGwPsOpy2TH-WdAWKpSKf_6QL4JGT-2v-z?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

Each bin operates as a constant sum market with a unique bonding curve, defined by a static price and dynamic liquidity reserves. The y-intercept in the figure below shows total liquidity (L), with the slope set by the bin’s price.

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXduCBtA2OF2Yw9wedysWTxtj3HruUIxODOmpdEdbNWzIsdo1sDfVltDDGsKMJhtZA19i-8JTb69Kmo_lWAAzHQz1GRlTcur8xPWlCV2Qtnm-9BJU-OZCGrqKlgWLsaEqoxaPcSC?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption><p>Reserves Bonding Curve</p></figcaption></figure>

#### 3. Bin Composition

The reserve composition in a liquidity bin is independent of price and liquidity. A composition factor (c), defined as the percentage of bin liquidity held as Y reserves, describes available reserves and is bounded between 0 and 1.

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXciJ6TUXfASRDQy47yj11XAa5ORNaBgbH8wqQTFgAQ9S0rmFOPnZv9jaNtEB4mgDiCgeT_5vVh1QX1VLSNGQmhWLGwHDEcW5lQDqnAVbQjBzcXasO-xDXn3rHoVAv9JrAaLFgsurg?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

Asset reserves of each liquidity bin can be fully described by bin liquidity (L) and composition (c)

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXdv7_5_PK2klrhPqZlFdxw-C6WmEAQLAXXcU0AxlaoVVdkerxuP-wQL8PAqUboo03EGXS9yTTQrXWmpy3HwrL6IZkxUfLte9UrwQlsJLOWu-L9UUtQrFcR3GBO-5_Ye_hqVWMFT8w?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

#### 4. Market Aggregation

Combining liquidity bins for an asset pair forms the market. As market prices shift, bin reserves transition between X and Y assets. Bins priced below the market hold only Y, while those above hold only X. The market price is set by the lowest-priced bin containing X reserves.

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXc0yQ_YvhmRPVYsARlAkgB5KTWOfo1xpZyPEBqiedRU-ts8mE0wjY-0juRQsNpN8eqmHmB27CaO2wrI6nlUJQ231qFCNzJ3EkozJTH_oG-4UG7g5mj-Lqp9B7Znak9VIFyI4-j64A?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption><p>Aggregate Liquidity Composition</p></figcaption></figure>

#### 5. Market Making&#x20;

Discrete liquidity bins enable liquidity providers to tailor liquidity structures to their goals, predictions, and risk profiles. Providers can focus liquidity around specific price points or spreads and adjust individual bins without affecting others.

The liquidity book design supports precise range and depth adjustments for effective market making.

### Product Architecture

#### 1. Market Definition

The market price range is limited to (2⁻¹²⁸, 2¹²⁸) and divided into bins based on a bin step (s).

Smaller bin steps create more bins. A market is defined by the (X, Y, s) set. The total number of bins is 2\*Nb, where Nb is the maximum number of bins between price parity and the maximum price for a given bin step.

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXfQ2n_oAJd31ZFN7W3s2h8NqtMX2ZIm2wRmC-FPXGlEOiYHN28JWy9HM-hGuFfWuAqvu8GT1mqa6e1s0q6JpclknOdVW_xNp3Xn666BII7_bMEXoGPsMlFkwp4fUYjy00sDe9avsw?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

The maximum number of bins is capped below 2²⁴, with half assigned below and half above price parity. In a market with the maximum bins, the parity bin identifier is 2²³, denoted as constant b. Each bin receives a positive integer identifier (i) ranging from \[b - Nb, b + Nb].

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXdojQqjmOqZx0psH4KPMzITfJDyUOSB3KENHA_ToVXQp33aVCe4JprE4fD5J6GDyYY_IhIXpcCFYDEJz4TfEWWfE82YenLzAmDlFAofJ6AOen-z1a1dHiFLMPiEztkdLYQ8VqrguQ?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

#### 2. Bin Price

The price prescribed to each bin is a function of the pair’s bin step (s) and the bin’s identifier (i). The bin step parameter determines the constant percentage increase or decrease in price between each incremental bin.&#x20;

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXfm_aGWUPO5F866JWizoZuyfaYxm0Q1-zIj7EYZn--J35OSehardKZt83yoAzechpAR_AIur3lKll7-DpCrgGRhe2LQsxyLhDtAXCPURQgXjuT8jhl0of5WB7fOGuZEsf6ILJOs?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

#### 3. Liquidity Tracking

Liquidity bins are indexed in a tree structure using three nested 256-bit arrays. Each bin is assigned a location path in the arrays, with non-zero values indicating bins containing liquidity.&#x20;

This tree enables efficient liquidity state searches during swaps and external monitoring.\\

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXcIWx9U9QU1Xw1m8-wxzbZ2Vr99cZTFUVKCXdqDsnsgFxRYg2xmbx0OQry4B5P6gUBslMij3QvdAWfQB9zOqeVTPYZpth9-t5HsWKwSwyxiRiNTRN_6WpZHS0iJq9AXAh-AUSe3-w?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption><p>Bin Index Tree</p></figcaption></figure>

#### 4. Trade Routing

The LB router will provide added security and slippage checks for swaps and liquidity deposits/withdrawals. Swaps will also be routed through legacy AMM pairs when better pricing is found.

#### 5. Liquidity Tokens

The LB protocol introduces LBToken, a new liquidity token standard tailored for its numerous bins. Liquidity (L) in LB markets is valued uniformly in Y terms, independent of bin state, making it composable across bins.

#### 6. Market Parameters

Each market has fee rate parameters, detailed in next sections, initially set based on the chosen bin step. Markets can only be created with bin steps linked to predefined fee parameters in the factory. These parameters can be adjusted post-initialization

#### 7. Oracles

Saros DLMM markets feature an oracle that logs&#x20;

- timestamp
- cumulativeID
- cumulativeAccumulator
- cumulativeBinCrossed&#x20;

These cumulative values help track changes over time, providing market price and volatility/fee metrics for algorithmic trading and liquidity provision. The sampleLifetime, set at market creation, determines the sampling rate, and users can increase the oracle sample size as needed.

### User Interactions

#### 1. Add / Remove Liquidity

Adding or removing liquidity from an active bin maintains the price (P) and composition (c). The required amounts of reserve X and Y for a liquidity adjustment.&#x20;

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXcI_Zz04MKtd0M48bmWAPep6N-N1xL-pd0h6PaDAkLFgjxzI5vNgXu0LB0JZlQD0YUuNFQ2bIagW0co4s7EGM93WywO564h9ntm6M6klUQow6WgxEme5P5Gdrg7PiOVCaec-lN2lA?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

For all ‘inactive’ liquidity bins, liquidity can be added exclusively in reserve X or reserve Y as determined by the composition bounds.&#x20;

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXeJjZvC14ADmKW7BzSy8RCyf6x2o_-wzItVCJDClhFDCMij546SVA3MeZI-yebFh019qw3GFT6A_51bzEuKyso1IezEzqc5ou1U3sIPzvL446ZrU-xBDCUD-QC3Mn8BmbUtlDLwrQ?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

Liquidity added to an active bin is automatically swapped if it mismatches the bin’s composition, incurring a fee. Attempts to add liquidity to inactive bins that don’t align with the bin’s composition will fail.

#### 2. Swaps

Exchanging reserves in a liquidity bin preserves liquidity and price, altering only the reserve composition. Reserves are swapped, with composition staying within \[0,1].

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXfuUXFErcuXl41ULwl5Geo3v1zGss8VExzHC2Cck1ici-4I5zZYZTkGFMPJ2OaQWM3tgYdDYEJJuZqRMeK6j1fL3Q9UQjzXmaj8Xjb9TQGfHaPH1_-wD_xyhvnYfUHIunzPS55s?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

The reserves that are available in the liquidity bin until the composition bounds are reached can be calculated:

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXex0DcB5OLNqBBNASHq9-qcHciouaw0_JoKlqpAIoHaW00F4Ig4rb2v0DtGxMK6sCJsfNkJ4VHECA0ZaZ0WZUPDjKvXUgv-TFLQKDUWYGnsv1uGfXAnTFoOBwDS69lENlTBR9O9rQ?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

When a swap exceeds the liquidity in a bin, it depletes each consecutive bin’s liquidity before moving to the next adjacent bin with available liquidity.

#### 3. Swap fees

The protocol collects fees to reward liquidity providers for trading activity. The total swap fee (fs) includes a base fee (fb) and a variable fee (fv) based on price volatility.&#x20;

Fees are applied to the swap amount in each bin, distributed proportionally to providers after a protocol share, and held separately for providers to claim. The total fee for a swap across n bins is calculated:\\

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXfZwPyBQOwnrH47kp7I1oiuB1wCWPE438I8-IJiZMNYiOsBlXCdp06iKUg3cnXA4T_q9EPGcCMuwdHEjrjxpYwK2wQkmYmHh38eR9nR6jizYdOj0EDO8fLJ0fMA3Bu93xv5WxMZbw?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

**Base fee**

The base fee represents the minimum rate for all swaps. The base fee rate (fb) is a function of the bin step (s) and is scaled by a baseFactor (B)

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXe9p0JomWGCs3yrwWxWzSyR3VdCrKM3JD5TEZGEwMtiFl6RN0SdxSjp8z3RjOZv6nd3BlzWs1mFO6sr4_RXIiwL2DQMeLbLW8V-QDv8TtOpVG5YJ-_rNCx7O3tQX64gfivZ9UeTtg?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

**Variable fee**

The variable fee (fv) is designed to compensate liquidity providers for instantaneous volatility and incentivize liquidity providers to actively manage liquidity around a moving price. The variable fee is calculated per bin (k)&#x20;

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXfMjAzpF51mkZff-eIGtY9sMvcjnk6Lq96E-dEuKru43hcRCYcjNFJklVeCW15W7zvet-BwhQxE2HVOiyosrcJBFfk89wazBwU_fSydxaShstuBc0jE05zKgHdlxxMKcQRgxZIrGA?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

Instantaneous volatility is tracked by the volatility accumulator variable (va). The variableFeeControl parameter (A) scales the variable fee component based on expected market dynamics.

**Volatility Accumulator**

Volatility is based on bin changes over time, with each change reflecting a fixed price movement set by the bin step.&#x20;

A volatility accumulator (va) measures bin crossovers across transactions, using the number of crossovers (k), a reference bin index (ir), the starting active bin (ik=0), and a reference volatility value (vr)

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXcwTLBXLQy75s3qMYc1nfAD5zxdLcEUZfhnxVgpFzgt91sy1S93r4mIe9M6HkJlTD6uPpX8pm7JrV9ymZp3cuq-Pz4LDrlkcSS4XnoggqsncdMlA33ADczzQwauQzJKpEW5fUvvjQ?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

Where the reference values are calculated at the beginning of each transaction and depend on time elapsed since the last transaction (t)

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXdJHMjZSEyyit1TiJllZwN0dzlTnqWKAMCokqq-Z7rQ9ct3fIxcd2qFgmnMvJg_0GtROIeChtlYx5q5xhl0P7HDtBz6Pa0QfXI1B7Gcdf6S8GFraD10LMV42JA4gB644lupUQcTkQ?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

The volatility accumulator calculates the bin distance from the swap bin to a reference bin, adding a carryover volatility (vr). The reference bin updates to the current bin if no transactions occur for a period exceeding the filterPeriod (tf).&#x20;

Reference volatility updates based on transaction frequency, decaying by the reductionFactor R when time exceeds tf, or resetting to 0 when exceeding the decayPeriod (td). A maxAccumulator parameter (vmax) limits the accumulator to prevent excessive fees.

#### 4. Active Bin Composition Fee

Liquidity added to the active bin is automatically swapped across reserves if its composition differs from the bin’s. The swap amount ensures the bin’s assets match those from a prior swap, incurring a fee similar to the current market swap fee.

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXf1M3LcMXPH38nHmanMKGLouYcvmMJLvc2ekMcL9eyzrdJBewNGAqoeltuPC94Hnn0fuZI-U8JWIDh7EEB-2EWdPmw3Qx6I-m7rVnlGVm47PdWnY6hpL0T0pyH0-Psy6nQZCW-MWw?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

#### 5. Protocol Fee

A portion of swap fees, set by the protocolShare parameter, is retained by the protocol (fp). Each market has its own protocolShare to manage fee distribution. Remaining fees are distributed to liquidity providers.

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXd8Qlx-iJnzGDPadIcR9H2Tm5wWbq7dR-FC4fP9-Rmi7HKt5atL7D59FadE0a0tP1qDf8_46Zele0wg-PwsOR9EKGaWP1Vqq2UCLqTiAYKma50EMgO0elw65YGaR1YEI_zvOI-6zA?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption></figcaption></figure>

### Improvements

#### 1. Impermanent Loss (IL)&#x20;

Variable fees compensate liquidity providers for IL caused by price volatility, with the volatility accumulator adjusting fees to market conditions. Providers can outperform expected payoffs due to the accumulator’s time decay, as shown in below figure.&#x20;

However, tracking errors occur during highly volatile events due to significant nominal price changes, as the accumulator relies on bin steps.\\

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXfFoCe-gQwn1pgwivs8iHea58CtBvJonCaQ1QiUmV6IOLGi_DBsBVhF_skMxnZrAWqtR6mU3_xMEfA5iHYy_wMpheSOym7GNKrA3ckrMFjD7T-ThKnpPmZ3aOW4hCgnyDMU_qPz?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption><p>Fee Adjusted Per IL</p></figcaption></figure>

#### 2. Liquidity Depth&#x20;

Enhancing the DEX capital efficiency increases market depth for a given capital amount. Capital efficiency is the reduction in capital needed to match v1 liquidity.&#x20;

For Saros DLMM, equivalent liquidity aligns the price impact of a v1 swap with a single bin step. The efficiency equation is provided, with maximum efficiency limits for each market and bin step.

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXcF1xrxRtDVDR_Cq7ryKD6yoOkhMQQktfmzbzLi4b-mh5iLDJjkT6zN9QwvON4djZaCqiEFS8PhI1JESiC919zkMoGRl-KTsJO2FyriofjI_aK-17a3nK-WB3UWMENCCY5ZcXvEow?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption><p>Capital Efficiency Limits</p></figcaption></figure>

From the above figure, capital efficiency is similar to Uniswap v3 (v3). An evenly distributed LB position approximates a v3 position.&#x20;

If liquidity is equally spread across bins in X tokens, the swap value difference between LB and v3 is calculated, and can be plotted for positions with varying price ranges and bin steps.

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXdVfA0ESCDWiNk7sIUoGzcsu6Ja96vVD8bL_q_QX3EazrxVOkdzNzSn9UEe3K3IgZFICuSCatjrB2UCC-gL5Fsqc5lJPtkBryiE-na_oL0tIuaWNHWA29pEVF2FFcj_dJHfd9FR?key=atS-5TtbgIpShv0ORYNSRfn2" alt=""><figcaption><p>Market Depth compared to Uni v3</p></figcaption></figure>

The figure shows that position price range impacts market depth more than bin structure.&#x20;

For positions spanning at least two bins, depth differences across bin steps are minimal. With the specified distribution, LB’s market depth is within 1% of Uniswap v3 for positions under a 60% price range.&#x20;

Depth differences, mainly due to liquidity distribution compared to v3’s geometric sequence, are only significant for large-range positions, highlighting the value of LB’s flexible liquidity distribution.

skip to:contentpackage searchsign in
❤
Pro
Teams
Pricing
Documentation
npm
Search packages
Search
@saros-finance/dlmm-sdk
TypeScript icon, indicating that this package has built-in type declarations
1.4.0 • Public • Published a month ago
Saros DLMM
The engine that powers the Internet Capital Market on Solana.

Installation
Use your environment's package manager to install @saros-finance/dlmm-sdk into your project.

yarn add @saros-finance/dlmm-sdk
npm install @saros-finance/dlmm-sdk
Usage
import {
BIN_STEP_CONFIGS,
LiquidityBookServices,
MODE,
} from "@saros-finance/dlmm-sdk";
import { PublicKey, Transaction, Keypair } from "@solana/web3.js";
import {
LiquidityShape,
PositionInfo,
RemoveLiquidityType,
} from "@saros-finance/dlmm-sdk/types/services";
import {
createUniformDistribution,
findPosition,
getBinRange,
getMaxBinArray,
getMaxPosition,
} from "@saros-finance/dlmm-sdk/utils";
import bigDecimal from "js-big-decimal";
import { bs58 } from "@coral-xyz/anchor/dist/cjs/utils/bytes";

const liquidityBookServices = new LiquidityBookServices({
mode: MODE.MAINNET,
});

const YOUR_WALLET = "";

// Pool example on saros C98 to USDC
const USDC_TOKEN = {
id: "usd-coin",
mintAddress: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
symbol: "usdc",
name: "USD Coin",
decimals: 6,
addressSPL: "FXRiEosEvHnpc3XZY1NS7an2PB1SunnYW1f5zppYhXb3",
};

const C98_TOKEN = {
id: "coin98",
mintAddress: "C98A4nkJXhpVZNAZdHUA95RpTF3T4whtQubL3YobiUX9",
symbol: "C98",
name: "Coin98",
decimals: 6,
addressSPL: "EKCdCBjfQ6t5FBfDC2zvmr27PgfVVZU37C8LUE4UenKb",
};

const POOL_PARAMS = {
address: "EwsqJeioGAXE5EdZHj1QvcuvqgVhJDp9729H5wjh28DD",
baseToken: C98_TOKEN,
quoteToken: USDC_TOKEN,
slippage: 0.5,
hook: "", // config for reward, adding later
};

const WSOL_TOKEN_DEVNET = {
id: "wsol",
mintAddress: "So11111111111111111111111111111111111111112",
symbol: "WSOL",
name: "WSOL",
decimals: 9,
}

const SAROS_TOKEN_DEVNET = {
id: "saros",
mintAddress: "mntCAkd76nKSVTYxwu8qwQnhPcEE9JyEbgW6eEpwr1N",
symbol: "DEXV3-SAROS",
name: "Dex V3 Saros",
decimals: 6,
}

const POOL_PARAMS_DEVNET = {
address: "C8xWcMpzqetpxwLj7tJfSQ6J8Juh1wHFdT5KrkwdYPQB",
baseToken: SAROS_TOKEN_DEVNET,
quoteToken: SOL_TOKEN_DEVNET,
slippage: 0.5,
hook: "", // config for reward, adding later
};

const onSwap = async () => {
const amountFrom = 1e6 // Token C98
const quoteData = await liquidityBookServices.getQuote({
amount: BigInt(amountFrom),
isExactInput: true, // input amount in
swapForY: true, // swap from C98 to USDC
pair: new PublicKey(POOL_PARAMS.address),
tokenBase: new PublicKey(POOL_PARAMS.baseToken.mintAddress),
tokenQuote: new PublicKey(POOL_PARAMS.quoteToken.mintAddress),
tokenBaseDecimal: POOL_PARAMS.baseToken.decimals,
tokenQuoteDecimal: POOL_PARAMS.quoteToken.decimals,
slippage: POOL_PARAMS.slippage
})

    const { amountIn, amountOut, priceImpact, amount, otherAmountOffset } =
    	quoteData // slippage included

    const transaction = await liquidityBookServices.swap({
    	amount,
    	tokenMintX: new PublicKey(POOL_PARAMS.baseToken.mintAddress),
    	tokenMintY: new PublicKey(POOL_PARAMS.quoteToken.mintAddress),
    	otherAmountOffset,
    	hook: new PublicKey(liquidityBookServices.hooksConfig), // Optional, if you have a hook for reward
    	isExactInput: true, // input amount in
    	swapForY: true, // swap from C98 to USDC
    	pair: new PublicKey(POOL_PARAMS.address),
    	payer: new PublicKey(YOUR_WALLET) // Replace with your wallet public key
    })

    const signedTransaction = signTransaction(transaction);

    const signature = await liquidityBookServices.connection.sendRawTransaction(
    signedTransaction.serialize(),
    	{
    		skipPreflight: true,
    		preflightCommitment: "confirmed",
    	}
    );

    const { blockhash, lastValidBlockHeight } = await liquidityBookServices.connection.getLatestBlockhash();

    await liquidityBookServices.connection.confirmTransaction({
    	signature,
    	blockhash,
    	lastValidBlockHeight,
    });

};

// Get Dex Name
const getDexName = () => {
try {
const response = liquidityBookServices.getDexName();
return response;
} catch (error) {
return "";
}
};

// Get Dex Program ID
const getDexProgramId = () => {
try {
const response = liquidityBookServices.getDexProgramId();
return response;
} catch (error) {
return "";
}
};

// Query all pools on Saros DLMM
const getPoolAddresses = async () => {
try {
const response = await liquidityBookServices.fetchPoolAddresses();
return response;
} catch (error) {
return [];
}
};

// Fetch Pool Metatdata
const fetchPoolMetadata = async () => {
try {
const response = await liquidityBookServices.fetchPoolMetadata(
POOL_PARAMS.address
);
return response;
} catch (error) {
return {};
}
};

// Listen new pool address
const onListenNewPoolAddress = async () => {
const postTx = async (poolAddres: string) => {
console.log("🚀 ~ onListenNewPoolAddress ~ poolAddres:", poolAddres);
};
await liquidityBookServices.listenNewPoolAddress(postTx);
};

const convertBalanceToWei = (strValue: number, iDecimal: number = 9) => {
if (strValue === 0) return 0;

try {
const multiplyNum = new bigDecimal(Math.pow(10, iDecimal));
const convertValue = new bigDecimal(Number(strValue));
const result = multiplyNum.multiply(convertValue);
return result.getValue();
} catch {
return 0;
}
};

// Create Pool
const onCreatePool = async () => {
const connection = liquidityBookServices.connection;
const tokenX = C98_TOKEN;
const tokenY = USDC_TOKEN;
const binStep = BIN_STEP_CONFIGS[3].binStep; // Example bin step, you can choose from BIN_STEP_CONFIGS
const ratePrice = 1; // Example rate price, you can set it based on your requirements
const payer = new PublicKey(YOUR_WALLET);

    const { blockhash, lastValidBlockHeight } =
      await connection!.getLatestBlockhash({
        commitment: "confirmed",
      });

    const { tx } = await liquidityBookServices.createPairWithConfig({
      tokenBase: {
        mintAddress: tokenX.mintAddress,
        decimal: tokenX.decimals,
      },
      tokenQuote: {
        mintAddress: tokenY.mintAddress,
        decimal: tokenY.decimals,
      },
      ratePrice,
      binStep,
      payer,
    });
    tx.recentBlockhash = blockhash;
    tx.feePayer = payer;

    const response = await window.coin98?.sol.signTransaction(tx);
    if (response) {
      const publicKey = new PublicKey(response.publicKey);

      tx.addSignature(publicKey, bs58.decode(response.signature) as Buffer);

      const txSerialize = tx.serialize();

      const transactionHash = await connection?.sendRawTransaction(
        txSerialize,
        {
          skipPreflight: true,
          preflightCommitment: "confirmed",
        }
      );

      await connection!.confirmTransaction(
        { signature: transactionHash!, blockhash, lastValidBlockHeight },
        "finalized"
      );
    }

};

// Add liquidity
const onAddliquidity = async () => {
const tokenX = C98_TOKEN;
const tokenY = USDC_TOKEN;

    const payer = new PublicKey(YOUR_WALLET);
    const pair = new PublicKey(POOL_PARAMS.address);
    const shape = LiquidityShape.Spot;
    const binRange = [-10, 10] as [number, number]; // Example bin range
    const positions = await liquidityBookServices.getUserPositions({
      payer,
      pair,
    });
    const pairInfo = await liquidityBookServices.getPairAccount(pair);
    const activeBin = pairInfo.activeId;

    const connection = liquidityBookServices.connection;

    const { blockhash, lastValidBlockHeight } =
      await connection.getLatestBlockhash();

    let currentBlockhash = blockhash;
    let currentLastValidBlockHeight = lastValidBlockHeight;

    const maxPositionList = getMaxPosition(
      [binRange[0], binRange[1]],
      activeBin
    );

    const maxLiqDistribution = createUniformDistribution({
      shape,
      binRange,
    });

    const binArrayList = getMaxBinArray(binRange, activeBin);

    const allTxs: Transaction[] = [];
    const txsCreatePosition: Transaction[] = [];

    const initialTransaction = new Transaction();

    await Promise.all(
      binArrayList.map(async (item) => {
        await liquidityBookServices.getBinArray({
          binArrayIndex: item.binArrayLowerIndex,
          pair: new PublicKey(pair),
          payer,
          transaction: initialTransaction,
        });

        await liquidityBookServices.getBinArray({
          binArrayIndex: item.binArrayUpperIndex,
          pair: new PublicKey(pair),
          payer,
          transaction: initialTransaction,
        });
      })
    );

    await Promise.all(
      [tokenX, tokenY].map(async (token) => {
        await liquidityBookServices.getPairVaultInfo({
          payer,
          transaction: initialTransaction,
          tokenAddress: new PublicKey(token.mintAddress),
          pair: new PublicKey(pair),
        });
        await liquidityBookServices.getUserVaultInfo({
          payer,
          tokenAddress: new PublicKey(token.mintAddress),
          transaction: initialTransaction,
        });
      })
    );

    if (initialTransaction.instructions.length > 0) {
      initialTransaction.recentBlockhash = currentBlockhash;
      initialTransaction.feePayer = payer;
      allTxs.push(initialTransaction);
    }

    const maxLiquidityDistributions = await Promise.all(
      maxPositionList.map(async (item) => {
        const {
          range: relativeBinRange,
          binLower,
          binUpper,
        } = getBinRange(item, activeBin);
        const currentPosition = positions.find(findPosition(item, activeBin));

        const findStartIndex = maxLiqDistribution.findIndex(
          (item) => item.relativeBinId === relativeBinRange[0]
        );
        const startIndex = findStartIndex === -1 ? 0 : findStartIndex;

        const findEndIndex = maxLiqDistribution.findIndex(
          (item) => item.relativeBinId === relativeBinRange[1]
        );
        const endIndex =
          findEndIndex === -1 ? maxLiqDistribution.length : findEndIndex + 1;

        const liquidityDistribution = maxLiqDistribution.slice(
          startIndex,
          endIndex
        );

        const binArray = binArrayList.find(
          (item) =>
            item.binArrayLowerIndex * 256 <= binLower &&
            (item.binArrayUpperIndex + 1) * 256 > binUpper
        )!;

        const binArrayLower = await liquidityBookServices.getBinArray({
          binArrayIndex: binArray.binArrayLowerIndex,
          pair: new PublicKey(pair),
          payer,
        });
        const binArrayUpper = await liquidityBookServices.getBinArray({
          binArrayIndex: binArray.binArrayUpperIndex,
          pair: new PublicKey(pair),
          payer,
        });

        if (!currentPosition) {
          const transaction = new Transaction();

          const positionMint = Keypair.generate();

          const { position } = await liquidityBookServices.createPosition({
            pair: new PublicKey(pair),
            payer,
            relativeBinIdLeft: relativeBinRange[0],
            relativeBinIdRight: relativeBinRange[1],
            binArrayIndex: binArray.binArrayLowerIndex,
            positionMint: positionMint.publicKey,
            transaction,
          });
          transaction.feePayer = payer;
          transaction.recentBlockhash = currentBlockhash;

          transaction.sign(positionMint);

          txsCreatePosition.push(transaction);
          allTxs.push(transaction);

          return {
            positionMint: positionMint.publicKey.toString(),
            position,
            liquidityDistribution,
            binArrayLower: binArrayLower.toString(),
            binArrayUpper: binArrayUpper.toString(),
          };
        }

        return {
          positionMint: currentPosition.positionMint,
          liquidityDistribution,
          binArrayLower: binArrayLower.toString(),
          binArrayUpper: binArrayUpper.toString(),
        };
      })
    );

    const txsAddLiquidity = await Promise.all(
      maxLiquidityDistributions.map(async (item) => {
        const {
          binArrayLower,
          binArrayUpper,
          liquidityDistribution,
          positionMint,
        } = item;
        const transaction = new Transaction();
        await liquidityBookServices.addLiquidityIntoPosition({
          amountX: Number(convertBalanceToWei(10, tokenX.decimals)),
          amountY: Number(convertBalanceToWei(10, tokenY.decimals)),
          binArrayLower: new PublicKey(binArrayLower),
          binArrayUpper: new PublicKey(binArrayUpper),
          liquidityDistribution,
          pair: new PublicKey(pair),
          positionMint: new PublicKey(positionMint),
          payer,
          transaction,
        });

        transaction.recentBlockhash = currentBlockhash;
        transaction.feePayer = payer;

        allTxs.push(transaction);
        return transaction;
      })
    );
    const response = await window.coin98.sol.signAllTransactions(allTxs);
    const publicKey = new PublicKey(response.publicKey);
    const signatures = response.signatures;

    const signedTxs = allTxs.map((transaction, index) => {
      const signature = bs58.decode(signatures[index]!);
      transaction.addSignature(publicKey, signature);
      return transaction;
    });

    const hash: string[] = [];

    if (initialTransaction.instructions.length) {
      const tx = signedTxs.shift() || initialTransaction;
      const txHash = await connection.sendRawTransaction(tx.serialize(), {
        skipPreflight: false,
        preflightCommitment: "confirmed",
      });

      hash.push(txHash);

      await connection.confirmTransaction(
        {
          signature: txHash,
          blockhash: currentBlockhash,
          lastValidBlockHeight: currentLastValidBlockHeight,
        },
        "finalized"
      );

      const { blockhash, lastValidBlockHeight } =
        await connection.getLatestBlockhash();

      currentBlockhash = blockhash;
      currentLastValidBlockHeight = lastValidBlockHeight;
    }
    if (txsCreatePosition.length) {
      await Promise.all(
        txsCreatePosition.map(async (tx) => {
          const serializeTx = (signedTxs.shift() || tx).serialize();

          const txHash = await connection.sendRawTransaction(serializeTx, {
            skipPreflight: false,
            preflightCommitment: "confirmed",
          });

          hash.push(txHash);

          await connection.confirmTransaction(
            {
              signature: txHash,
              blockhash: currentBlockhash,
              lastValidBlockHeight: currentLastValidBlockHeight,
            },
            "finalized"
          );
          hash.push(txHash);
        })
      );

      const { blockhash, lastValidBlockHeight } =
        await connection!.getLatestBlockhash();

      currentBlockhash = blockhash;
      currentLastValidBlockHeight = lastValidBlockHeight;
    }

    // Transaction for adding liquidity
    await Promise.all(
      txsAddLiquidity.map(async (tx) => {
        const serializeTx = (signedTxs.shift() || tx).serialize();

        const txHash = await connection.sendRawTransaction(serializeTx, {
          skipPreflight: false,
          preflightCommitment: "confirmed",
        });
        if (!txHash) return;

        hash.push(txHash);

        await connection!.confirmTransaction(
          {
            signature: txHash,
            blockhash: currentBlockhash,
            lastValidBlockHeight: currentLastValidBlockHeight,
          },
          "finalized"
        );
      })
    );

    console.log("Transaction hashes:", hash);

};

// Remove liquidity
const onRemoveLiquidity = async () => {
const tokenX = C98_TOKEN;
const tokenY = USDC_TOKEN;
const connection = liquidityBookServices.connection;
const type = RemoveLiquidityType.Both;
const pair = new PublicKey(POOL_PARAMS.address);
const payer = new PublicKey(YOUR_WALLET);

    if (!type) {
      throw new Error("Invalid parameters");
    }

    const pairInfo = await liquidityBookServices.getPairAccount(pair);

    const activeId = pairInfo.activeId;

    const range = [activeId - 3, activeId + 3] as [number, number]; // Example range

    const positions = await liquidityBookServices.getUserPositions({
      payer,
      pair,
    });

    const positionList = positions.filter((item: PositionInfo) => {
      return !(item.upperBinId < range[0] || item.lowerBinId > range[1]);
    });

    if (!positionList.length) throw Error("No position found in this range");

    const maxPositionList = positionList.map((item: PositionInfo) => {
      const start = range[0] > item.lowerBinId ? range[0] : item.lowerBinId;
      const end = range[1] < item.upperBinId ? range[1] : item.upperBinId;

      return {
        position: item.position,
        start,
        end,
        positionMint: item.positionMint,
      };
    });

    const { blockhash, lastValidBlockHeight } =
      await connection!.getLatestBlockhash({
        commitment: "confirmed",
      });

    const { txs, txCreateAccount, txCloseAccount } =
      await liquidityBookServices.removeMultipleLiquidity({
        maxPositionList: maxPositionList,
        payer,
        type,
        pair: new PublicKey(pair),
        tokenMintX: new PublicKey(tokenX.mintAddress),
        tokenMintY: new PublicKey(tokenY.mintAddress),
        activeId,
      });

    const allTxs = [...txs];

    if (txCreateAccount) {
      allTxs.unshift(txCreateAccount);
    }
    if (txCloseAccount) {
      allTxs.push(txCloseAccount);
    }

    allTxs.forEach((tx) => {
      tx.feePayer = payer;
      tx.recentBlockhash = blockhash;
    });

    const response = await window.coin98.sol.signAllTransactions(allTxs);
    const publicKey = new PublicKey(response.publicKey);
    const signatures = response.signatures;

    const signedTxs = allTxs.map((transaction, index) => {
      const signature = bs58.decode(signatures[index]!);
      transaction.addSignature(publicKey, signature);
      return transaction;
    });

    if (txCreateAccount) {
      const tx = signedTxs.shift() || txCreateAccount;
      const hash = await connection!.sendRawTransaction(tx.serialize(), {
        skipPreflight: true,
        preflightCommitment: "finalized",
      });

      await connection!.confirmTransaction({
        signature: hash,
        blockhash,
        lastValidBlockHeight,
      });
    }

    const {
      blockhash: newBlockhash,
      lastValidBlockHeight: newLastValidBlockHeight,
    } = await connection!.getLatestBlockhash({
      commitment: "confirmed",
    });

    const hash: string[] = [];
    await Promise.all(
      txs.map(async (_tx) => {
        const tx = signedTxs.shift() || _tx;
        const txHash = await connection!.sendRawTransaction(tx.serialize(), {
          skipPreflight: true,
          preflightCommitment: "confirmed",
        });

        hash.push(txHash);
        await connection!.confirmTransaction(
          {
            signature: txHash,
            blockhash: newBlockhash,
            lastValidBlockHeight: newLastValidBlockHeight,
          },
          "finalized"
        );
      })
    );

    if (txCloseAccount) {
      const tx = signedTxs.shift() || txCloseAccount;
      const txHash = await connection!.sendRawTransaction(tx.serialize(), {
        skipPreflight: true,
        preflightCommitment: "finalized",
      });

      hash.push(txHash);
    }
    console.log("🚀 ~ onRemoveLiquidity ~ hash:", hash);

};
Readme
Keywords
none
Package Sidebar
Install
npm i @saros-finance/dlmm-sdk

Weekly Downloads
160

Version
1.4.0

License
ISC

Unpacked Size
1.63 MB

Total Files
44

Last publish
a month ago

Collaborators
coin98_labs
Try on RunKit
Report malware
Footer
Support
Help
Advisories
Status
Contact npm
Company
About
Blog
Press
Terms & Policies
Policies
Terms of Use
Code of Conduct
Privacy
GitOwl
